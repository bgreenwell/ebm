---
title: "intro"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{intro}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
self_contained: false
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  echo = TRUE,
  cache = TRUE,
  fig.width = 6,
  fig.asp = 0.618,
  out.width = "70%"
)
```

**WARNING**: This vignette is very much a work in progress and is subject to change as the package evolves!


## Getting started

TBD. Talk about setting up **reticulate**, package installation via `install_interpret()`, etc.


## Using the **ebm** package

To illustrate the regression case, we'll use the `Hitters` data from the [ISLR2](https://cran.r-project.org/package=ISLR2) package. A sample of the data are shown below.

```{r setup}
data("Hitters", package = "ISLR2")

# Remove rows with missing response values
head(hitters <- Hitters[!is.na(Hitters$Salary), ])
```

We'll start by fitting a basic `EBMRegressor` to the `hitters` data set using `Salary` as the response. Note that the `ebm()` function currently only supports the usual R formula interface.

```{r ebm-regressor}
library(ebm)

# Fit a default EBM regressor
fit <- ebm(Salary ~ ., data = hitters, objective = "rmse")
fit  # still need to implement print() and summary() methods
```

You can obtain predictions using the familiar `predict()` method employed by most modeling packages in R. Note that through bagging, EBMs can provide standard errors for the predictions if requested.

```{r ebm-regressor-predict}
head(predict(fit, newdata = hitters))

# Ask for predictions and standard errors
head(predict(fit, newdata = hitters, se.fit = TRUE))
```
You can produce several [plotly](https://plotly.com/r/)-based graphs to help interpret the output of `"EBM"` objects using the generic `plot()` method; this function supports both global and local interpretations. The default simply prints a global measure of importance based on the sum of the absolute value of each variable sterm contributions. (For Markdown-type documents, like this vignette, you need to specify `display = "markdown"`; see `?ebm::plot` for details.)

```{r ebm-regressor-show-global-importance}
library(ggplot2)

theme_set(theme_bw())

# Plot feature importance (i.e., mean absolute scores)
plot(fit)
```

You can also plot the individual shape functions (or term contributions), as shown below:

```{r ebm-regressor-show-global-term}
plot(fit, term = "Years")
```
Plots can also optionally be interactive via HTML by setting `interactive = TRUE`:

```{r ebm-regressor-show-global-term-interactive}
plot(fit, term = "Years", interactive = TRUE, display = "markdown")
```

While the **ebm** package does not expose 100% of the functionality available in Python, you can pretty much do anything you need by interacting directly with the underlying Python objects (the magic happens through [reticulate](https://rstudio.github.io/reticulate/)). For instance, below we invoke the `monotonize()` method of `fit` to post process the term for `"Years"` by enforcing increasing monotonicity:

```{r ebm-regressor-show-global-term-mono}
fit$monotonize("Years", increasing = FALSE)
plot(fit, term = "Years")
```

```{r ebm-regressor-show-global-term-interaction}
plot(fit, term = c("Hits", "CAtBat"))
```

You can also display local explanations (though, one at a time) by specifying `local = TRUE`:

```{r ebm-regressor-show-local}
# Understand an individual prediction
x <- subset(hitters, select = -Salary)[1L, ]  # use first observation
plot(fit, local = TRUE, X = x, y = hitters$Salary[1L], geom = "col")
```
```{r ebm-regressor-show-local-interactive}
# Understand an individual prediction
plot(fit, local = TRUE, X = x, y = hitters$Salary[1L], display = "markdown")
```
