---
title: "intro"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{intro}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
self_contained: false
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  echo = TRUE,
  cache = TRUE
)
```

To illustrate the regression case, we'll use the `Hitters` data from the [ISLR2](https://cran.r-project.org/package=ISLR2) package. A sample of the data are shown below.

```{r setup}
data("Hitters", package = "ISLR2")

# Remove rows with missing response values
head(hitters <- Hitters[!is.na(Hitters$Salary), ])
```

We'll start by fitting a basic `EBMRegressor` to the `hitters` data set. Note that the `ebm()` function currently only supports the usual formula interface.

```{r ebm-regressor}
library(ebm)

# Fit a default EBM regressor
fit <- ebm(Salary ~ ., data = hitters, objective = "rmse")
fit  # still need to implement print() and summary() methods
```

You can obtain predictions using the familiar `predict()` method employed by most modeling packages in R. Note that thorugh bagging, EBMs can provide standard errors for the predictions if requested.

```{r ebm-regressor-predict}
head(predict(fit, newdata = hitters))
head(predict(fit, newdata = hitters, se.fit = TRUE))
```
You can produce several [plotly](https://plotly.com/r/)-based graphs to help interpret the output of `"EBM"` objects using the generic `plot()` method; this function supports both global and local interpretations. The default simply prints a global measure of importance based on the sum of the absolute value of each variable sterm contributions. (For Markdown-type documents, like this vignette, you need to specify `display = "markdown"`; see `?ebm::plot` for details.)

```{r ebm-regressor-show-global-importance}
plot(fit, display = "markdown")
```

You can also plot the individual shape functions (or term contributions), as shown below:

```{r ebm-regressor-show-global-term}
plot(fit, term = "Years", display = "markdown")
```

While the **ebm** package does not expose 100% of the functionality available in Python, you can pretty much do anything you need by interacting directly with the underlying Python objects (the magic happens through [reticulate](https://rstudio.github.io/reticulate/)). For instance, we invoke the `monottonize()` method to post process the term for `"Years"` by enforcing increasing monotonicity:

```{r ebm-regressor-show-global-term-mono}
fit$monotonize("Years", increasing = FALSE)
plot(fit, term = "Years", display = "markdown")
```

You can also display local explanations (though, one at a time) by specifying `local = TRUE`:

```{r ebm-regressor-show-local}
# Understand an individual prediction
x <- subset(hitters, select = -Salary)[1L, ]  # use first observation
plot(fit, local = TRUE, X = x, y = hitters$Salary[1L], display = "markdown")
```
